/*******************************************************************************
* Copyright 2014-2019 Intel Corporation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*******************************************************************************/

{% from 'jinjadefs.tmpl' import common %}

/* Common definitions across DAAl modules */
#include swigwarn.i
%include exception.i
%include python/exception.i
// shared pointers
%include "sp_list.i"

{% for i in common.ignore %}
%ignore {{i}};
{% endfor %}

/* Ignore all create() methods except mt19937::Batch::create */
%rename("%(regex:/.*(?<!mt19937::Batch)::create/$ignore/)s") "";

%typecheck(SWIG_TYPECHECK_DOUBLE_ARRAY)
(const daal::services::Collection<size_t> &)
{
    $1 = PySequence_Check($input);
}
%typemap(in)
(const daal::services::Collection<size_t> &)
(daal::services::Collection<size_t> *col_szt = NULL)
{
    Py_ssize_t n = PySequence_Length($input);
    if( n == 0 ) SWIG_fail;
    col_szt = new daal::services::Collection<size_t>(n);
    for( Py_ssize_t i=0; i<n; ++i ) {
        PyObject * o = PySequence_GetItem($input, i);
        size_t tmp = PyInt_AsSsize_t(o);
        if(PyErr_Occurred()) {
            PyErr_Format(PyExc_TypeError, "Sequence of integer values required");
            SWIG_fail;
        }
        (*col_szt)[i] = tmp;
    }
    $1 = col_szt;
}
%typemap(freearg)
(const daal::services::Collection<size_t> &)
{
    if( col_szt$argnum ) delete col_szt$argnum;
}


%typemap(out) (const daal::services::Collection<size_t>)
{
    size_t n = $1.size();
    $result = PyList_New(n);
    for( size_t i = 0; i < n; ++i ) {
        PyObject * tmp = PyLong_FromSsize_t(($1)[i]);
        if( tmp == NULL || PyList_SetItem($result, i, tmp) ) {
            PyErr_Format(PyExc_TypeError, "Could not fill sequence from Collection.");
            SWIG_fail;
        }
    }
}

%typemap(out) (const daal::services::Collection<size_t> &)
{
    size_t n = $1->size();
    $result = PyList_New(n);
    for( size_t i = 0; i < n; ++i ) {
        PyObject * tmp = PyLong_FromSsize_t((*$1)[i]);
        if( tmp == NULL || PyList_SetItem($result, i, tmp) ) {
            PyErr_Format(PyExc_TypeError, "Could not fill sequence from Collection.");
            SWIG_fail;
        }
    }
}


// Error code handler applies for particular method name (including constructors)
%define DAAL_ResultErrorsException(N)
%exception N {
  $action
  if( !result->_errors->isEmpty() ) { // accessign private member
    SWIG_Error(SWIG_RuntimeError, result->_errors->getDescription());
    SWIG_fail;
  }
}
%enddef

// General exception handler
%exception {
    try {
       $action
    }
    SWIG_CATCH_STDEXCEPT // catch std::exception
    catch (...) {
        SWIG_exception_fail(SWIG_UnknownError, "unknown exception from Intel(R) DAAL");
    }
}

%{
#define SWIG_FILE_WITH_INIT
//#define DAAL_NOTHROW_EXCEPTIONS // for DAAL_ResultErrorsException
//#define protected public //for DAAL_ResultErrorsException

#if PY_MAJOR_VERSION >= 3
# define PyInt_AsSsize_t PyLong_AsSsize_t
# define CHECK_STRING(s) PyUnicode_Check(s)
# define GET_STRING(s) PyUnicode_AsUTF8(s)
#else
# define CHECK_STRING(s) PyString_Check(s)
# define GET_STRING(s) PyString_AsString(s)
#endif

#include <daal.h>
#include <data_management/data_source/modifiers/csv/pyfeaturemodifier.h>
%}
