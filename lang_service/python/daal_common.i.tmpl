/*******************************************************************************
* Copyright 2014-2019 Intel Corporation.
*
* This software and the related documents are Intel copyrighted  materials,  and
* your use of  them is  governed by the  express license  under which  they were
* provided to you (License).  Unless the License provides otherwise, you may not
* use, modify, copy, publish, distribute,  disclose or transmit this software or
* the related documents without Intel's prior written permission.
*
* This software and the related documents  are provided as  is,  with no express
* or implied  warranties,  other  than those  that are  expressly stated  in the
* License.
*******************************************************************************/

{% from 'jinjadefs.tmpl' import common %}

/* Common definitions across DAAl modules */
#include swigwarn.i
%include exception.i
%include python/exception.i
// shared pointers
%include "sp_list.i"

{% for i in common.ignore %}
%ignore {{i}};
{% endfor %}

/* Ignore all create() methods except mt19937::Batch::create */
%rename("%(regex:/.*(?<!mt19937::Batch)::create/$ignore/)s") "";

%typecheck(SWIG_TYPECHECK_DOUBLE_ARRAY)
(const daal::services::Collection<size_t> &)
{
    $1 = PySequence_Check($input);
}
%typemap(in)
(const daal::services::Collection<size_t> &)
(daal::services::Collection<size_t> *col_szt = NULL)
{
    Py_ssize_t n = PySequence_Length($input);
    if( n == 0 ) SWIG_fail;
    col_szt = new daal::services::Collection<size_t>(n);
    for( Py_ssize_t i=0; i<n; ++i ) {
        PyObject * o = PySequence_GetItem($input, i);
        size_t tmp = PyInt_AsSsize_t(o);
        if(PyErr_Occurred()) {
            PyErr_Format(PyExc_TypeError, "Sequence of integer values required");
            SWIG_fail;
        }
        (*col_szt)[i] = tmp;
    }
    $1 = col_szt;
}
%typemap(freearg)
(const daal::services::Collection<size_t> &)
{
    if( col_szt$argnum ) delete col_szt$argnum;
}


%typemap(out) (const daal::services::Collection<size_t>)
{
    size_t n = $1.size();
    $result = PyList_New(n);
    for( size_t i = 0; i < n; ++i ) {
        PyObject * tmp = PyLong_FromSsize_t(($1)[i]);
        if( tmp == NULL || PyList_SetItem($result, i, tmp) ) {
            PyErr_Format(PyExc_TypeError, "Could not fill sequence from Collection.");
            SWIG_fail;
        }
    }
}

%typemap(out) (const daal::services::Collection<size_t> &)
{
    size_t n = $1->size();
    $result = PyList_New(n);
    for( size_t i = 0; i < n; ++i ) {
        PyObject * tmp = PyLong_FromSsize_t((*$1)[i]);
        if( tmp == NULL || PyList_SetItem($result, i, tmp) ) {
            PyErr_Format(PyExc_TypeError, "Could not fill sequence from Collection.");
            SWIG_fail;
        }
    }
}


// Error code handler applies for particular method name (including constructors)
%define DAAL_ResultErrorsException(N)
%exception N {
  $action
  if( !result->_errors->isEmpty() ) { // accessign private member
    SWIG_Error(SWIG_RuntimeError, result->_errors->getDescription());
    SWIG_fail;
  }
}
%enddef

// General exception handler
%exception {
    try {
       $action
    }
    SWIG_CATCH_STDEXCEPT // catch std::exception
    catch (...) {
        SWIG_exception_fail(SWIG_UnknownError, "unknown exception from Intel(R) DAAL");
    }
}

%{
#define SWIG_FILE_WITH_INIT
//#define DAAL_NOTHROW_EXCEPTIONS // for DAAL_ResultErrorsException
//#define protected public //for DAAL_ResultErrorsException

#if PY_MAJOR_VERSION >= 3
# define PyInt_AsSsize_t PyLong_AsSsize_t
# define CHECK_STRING(s) PyUnicode_Check(s)
# define GET_STRING(s) PyUnicode_AsUTF8(s)
#else
# define CHECK_STRING(s) PyString_Check(s)
# define GET_STRING(s) PyString_AsString(s)
#endif

#include <daal.h>
#include <data_management/data_source/modifiers/csv/pyfeaturemodifier.h>
%}
